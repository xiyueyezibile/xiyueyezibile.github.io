{
    "version": "https://jsonfeed.org/version/1",
    "title": "汐月也自闭了的个人博客 • All posts by \"数据结构与算法\" category",
    "description": "这个需求写不了",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/05/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "url": "http://example.com/2023/05/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/",
            "title": "动态规划",
            "date_published": "2023-05-26T10:06:01.431Z",
            "content_html": "<p>动态规划，无非就是利用<strong>历史记录</strong>，来避免我们的重复计算。而这些<strong>历史记录</strong>，我们得需要一些<strong>变量</strong>来保存，一般是用<strong>一维数组</strong>或者<strong>二维数组</strong>来保存。下面我们先来讲下做动态规划题很重要的三个步骤，</p>\n<p><strong>第一步骤</strong>：定义<strong>数组元素的含义</strong>，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp [] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp [i] 是代表什么意思？</p>\n<p><strong>第二步骤</strong>：找出<strong>数组元素之间的关系式</strong>，我觉得动态规划，还是有一点类似于我们高中学习时的<strong>归纳法</strong>的，当我们要计算 dp [n] 时，是可以利用 dp [n-1]，dp [n-2]……dp [1]，来推出 dp [n] 的，也就是可以利用<strong>历史数据</strong>来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp [n] = dp [n-1] + dp [n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。</p>\n<p><strong>第三步骤</strong>：找出<strong>初始值</strong>。学过<strong>数学归纳法</strong>的都知道，虽然我们知道了数组元素之间的关系式，例如 dp [n] = dp [n-1] + dp [n-2]，我们可以通过 dp [n-1] 和 dp [n-2] 来计算 dp [n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp [3] = dp [2] + dp [1]。而 dp [2] 和 dp [1] 是不能再分解的了，所以我们必须要能够直接获得 dp [2] 和 dp [1] 的值，而这，就是<strong>所谓的初始值</strong>。</p>\n<p><strong>从简单到复杂的解决</strong></p>\n<h2 id=\"案例一青蛙跳台阶\"><a class=\"markdownIt-Anchor\" href=\"#案例一青蛙跳台阶\">#</a> 案例一：青蛙跳台阶</h2>\n<p>问题描述：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">f</span><span class=\"params\">( <span class=\"type\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"comment\">// 先创建一个数组来保存历史数据</span></span><br><span class=\"line\">    <span class=\"comment\">//跳上一个 i 级的台阶总共有 dp[i] 种跳法</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 给出初始值</span></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 通过关系式来计算出 dp[n]</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">一种是从第 n-1 级跳上来</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">一种是从第 n-2 级跳上来</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        dp[i] = dp[i<span class=\"number\">-1</span>] + dp[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把最终结果返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"案例二最大子数组和\"><a class=\"markdownIt-Anchor\" href=\"#案例二最大子数组和\">#</a> 案例二：最大子数组和</h2>\n<p>给你一个整数数组  <code>nums</code>  ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><strong>子数组</strong> 是数组中的一个连续部分。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [5,4,-1,7,8]</span><br><span class=\"line\">输出：23</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 105</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n</ul>\n<p>** 进阶：** 如果你已经实现复杂度为  <code>O(n)</code>  的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//记录每一个以i位置元素为终点的连续子数组的最大和</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(nums.size())</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">//初始化</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> result = dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">//关系式</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//前一个连续数组最大值加上新数与新数本身比较选出最大值</span></span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>] + nums[i], nums[i]); <span class=\"comment\">// 状态转移公式</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dp[i] &gt; result) result = dp[i]; <span class=\"comment\">// result 保存dp[i]的最大值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        }
    ]
}