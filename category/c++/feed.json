{
    "version": "https://jsonfeed.org/version/1",
    "title": "汐月也自闭了的个人博客 • All posts by \"c++\" category",
    "description": "这个需求写不了",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/06/C++/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/",
            "url": "http://example.com/2023/08/06/C++/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/",
            "title": "c++类和对象",
            "date_published": "2023-08-05T16:15:21.472Z",
            "content_html": "<h2 id=\"类\"><a class=\"markdownIt-Anchor\" href=\"#类\">#</a> 类</h2>\n<p>c++ 是基于面向对象，但不是纯面向对象的语言，它可以面向对象与面向过程一起写。</p>\n<p>结构体升级成了类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">c</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"comment\">// c++里面的结构体可以定义成员函数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> b[<span class=\"number\">10</span>];<span class=\"comment\">// 成员变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">a</span> s1; <span class=\"comment\">// 兼容c</span></span><br><span class=\"line\">a s2; <span class=\"comment\">// c++可以直接定义</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"语法\"><a class=\"markdownIt-Anchor\" href=\"#语法\">#</a> 语法</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">className</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>类成员变量是每一个实例对象分别有的</p>\n<p>但类成员函数是公有的，有一个类成员函数表</p>\n<h3 id=\"访问限定符\"><a class=\"markdownIt-Anchor\" href=\"#访问限定符\">#</a> 访问限定符</h3>\n<p><code>public</code> , <code>private</code> , <code>protected</code></p>\n<ol>\n<li><code>public</code>  修饰的成员在类外可以直接被范围跟</li>\n<li><code>private</code>  和 <code>protected</code>  修饰的成员在类外不能直接被访问</li>\n<li>class 默认访问权限为 <code>private</code> ， <code>struct</code>  为 <code>public</code></li>\n</ol>\n<h3 id=\"计算类或对象大小\"><a class=\"markdownIt-Anchor\" href=\"#计算类或对象大小\">#</a> 计算类或对象大小</h3>\n<p>在底层都是按类进行计算</p>\n<p>可以通过 <code>sizeof</code>  进行计算，计算时不会算成员函数占的空间</p>\n<p>所以类的大小就是成员变量的大小，当然要注意内存对齐</p>\n<p>空类给了一个字节作为表示。</p>\n<h3 id=\"this指针\"><a class=\"markdownIt-Anchor\" href=\"#this指针\">#</a> this 指针</h3>\n<p>类型:  <code>类型* const</code></p>\n<p>this 指向调用函数的实例对象。</p>\n<p>类中成员函数会隐式添加一个 this 指针，但它在实参和形参位置不能显式写，</p>\n<p>但在类里面可以显式的用.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 编译后 void Init(Date* const this, int year);</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init</span><span class=\"params\">(<span class=\"type\">int</span> year)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this-&gt;_year = year;</span></span><br><span class=\"line\">        <span class=\"comment\">//在成员变量前面编译器会自动加this</span></span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 编译后 void Init(const Date* const this, int year);</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init1</span><span class=\"params\">(<span class=\"type\">int</span> year)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this-&gt;_year = year;</span></span><br><span class=\"line\">        <span class=\"comment\">//在成员变量前面编译器会自动加this</span></span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> year;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"this指针存在哪\"><a class=\"markdownIt-Anchor\" href=\"#this指针存在哪\">#</a> this 指针存在哪？</h4>\n<p>this 指针是一个形参，一般时存在栈帧里面</p>\n<p>vs 下面一般会用 <code>ecx</code>  寄存器直接传递</p>\n<h3 id=\"内置类型与自定义类型\"><a class=\"markdownIt-Anchor\" href=\"#内置类型与自定义类型\">#</a> 内置类型与自定义类型</h3>\n<p>内置类型时语言提供的数据类型，如：int/char，指针都是内置类型</p>\n<p>自定义类型就是我们使用 <code>class</code> / <code>struct</code> / <code>union</code>  等自己定义的类型</p>\n<h3 id=\"类的6个默认成员函数\"><a class=\"markdownIt-Anchor\" href=\"#类的6个默认成员函数\">#</a> 类的 6 个默认成员函数</h3>\n<p>初始化和清理：<strong>构造函数</strong>主要完成<strong>初始化</strong>工作，<strong>析构函数</strong>主要完成<strong>清理</strong>工作</p>\n<p>拷贝复制：<strong>拷贝构造</strong>时使用同类对象初始化创建对象，<strong>赋值重载</strong>主要时把一个对象赋值给另一个对象</p>\n<p>取地址重载：主要是普通对象和 <code>const</code>  对象取地址</p>\n<p>默认成员函数我们不写，编译器会自动生成。</p>\n<p>我们写了就不会生成了。</p>\n<h4 id=\"构造函数\"><a class=\"markdownIt-Anchor\" href=\"#构造函数\">#</a> 构造函数</h4>\n<p>构造函数时<strong>特殊的成员函数</strong>，需要注意的是，构造函数虽然名叫构造，但是构造函数的主要任务<strong>并不是开空间创建对象，而是初始化对象</strong>。</p>\n<p>特征如下：</p>\n<ol>\n<li>函数名与类名相同。</li>\n<li>无返回值。(不需要写 <code>void</code> )</li>\n<li>对象实例化时编译器<strong>自动调动</strong>对应的构造函数。</li>\n<li>构造函数可以重载。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>() &#123;</span><br><span class=\"line\">        _year = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year) &#123;</span><br><span class=\"line\">        _year = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> _year;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 无参构造调用</span></span><br><span class=\"line\">Date d2;</span><br><span class=\"line\"><span class=\"comment\">//有参构造调用</span></span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d2</span><span class=\"params\">(<span class=\"number\">2023</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>编译生成的默认构造的特点：</p>\n<ol>\n<li>我们不写才会生成，写了任意一个构造函数就不会生成</li>\n<li>内置类型的成员不会处理 (c++11 支持声明给缺省值)</li>\n<li>自定义类型成员才会处理，回去调用这个成员的<strong>构造函数</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> _year = <span class=\"number\">1</span>;<span class=\"comment\">// 声明给的缺省值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>无参的构造函数</strong>和<strong>全缺省的构造函数</strong>都叫做默认构造函数，但只能存在一个</p>\n<p>** 总结：** 一般情况都需要自己写，如果成员全是自定义类型可以考虑不写</p>\n<h4 id=\"析构函数\"><a class=\"markdownIt-Anchor\" href=\"#析构函数\">#</a> 析构函数</h4>\n<p>与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作由编译器完成，而<strong>对象在销毁时会自动调用析构函数，完成对对象中资源的清理工作。</strong></p>\n<p>特征如下：</p>\n<ol>\n<li>析构函数名实在类名前面加上字符 <code>~</code> 。</li>\n<li>无参数无返回类型。</li>\n<li>一个类只能有一个析构函数，如果没有显式定义，系统会自动生成默认的析构函数。析构函数不能重载。</li>\n<li>对象生命周期结束时，c++ 编译系统自动调用析构函数。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Date</span>() &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;~Date()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 析构函数后定义，先调用</span></span><br><span class=\"line\">Date s1;</span><br><span class=\"line\">Date s2;</span><br><span class=\"line\"><span class=\"comment\">// 先调用s2的析构函数</span></span><br></pre></td></tr></table></figure>\n<p>编译生成的默认析构函数特点与默认构造函数类似：</p>\n<ol>\n<li>内置类型的成员不会处理 (c++11 支持声明给缺省值)</li>\n<li>自定义类型成员才会处理，回去调用这个成员的<strong>构造函数</strong></li>\n</ol>\n<h4 id=\"拷贝构造函数\"><a class=\"markdownIt-Anchor\" href=\"#拷贝构造函数\">#</a> 拷贝构造函数</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year = <span class=\"number\">1</span>,<span class=\"type\">int</span> month = <span class=\"number\">1</span>,<span class=\"type\">int</span> day = <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">        _month = month;</span><br><span class=\"line\">        _day = day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _year = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">    <span class=\"type\">int</span> _day;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">2023</span>,<span class=\"number\">7</span>,<span class=\"number\">21</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>正常拷贝没有问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">(Date d)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// d是d1的浅拷贝（直接拷贝）;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但如果里面有在堆里面的空间，并且我们是在析构函数中释放它时</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当func1结束时</span></span><br><span class=\"line\"><span class=\"comment\">// d会先调用析构，释放该片空间</span></span><br><span class=\"line\"><span class=\"comment\">// d1再调用析构，就会报错</span></span><br></pre></td></tr></table></figure>\n<p>解决方法：</p>\n<ol>\n<li>引用 <code>void func1(Date&amp; d)</code> , 但并不好，在里面更改 d 会影响 d1</li>\n<li>拷贝构造函数</li>\n</ol>\n<p><strong>特征：</strong></p>\n<ul>\n<li>拷贝构造函数是<strong>构造函数的一个重载形式</strong>。</li>\n<li>拷贝构造好书的参数<strong>只有一个</strong>且必须是<strong>同类型对象的引用 (const 修饰)</strong>，使用<strong>传值方式编译器直接报错</strong>，因为会引发无穷递归调用 (如果传值，值又是一个实例对象，又要调拷贝构造，又要传值，就会无限递归)。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year = <span class=\"number\">1</span>,<span class=\"type\">int</span> month = <span class=\"number\">1</span>,<span class=\"type\">int</span> day = <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">        _month = month;</span><br><span class=\"line\">        _day = day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(Date&amp; d) &#123;</span><br><span class=\"line\">        _year = d.year;</span><br><span class=\"line\">        _month = d.month;</span><br><span class=\"line\">        _day = d.day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _year = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">    <span class=\"type\">int</span> _day;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"拷贝构造语法\"><a class=\"markdownIt-Anchor\" href=\"#拷贝构造语法\">#</a> <strong>拷贝构造语法：</strong></h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d2</span><span class=\"params\">(d1)</span></span>;</span><br><span class=\"line\">Date d3 = d1;</span><br><span class=\"line\"><span class=\"comment\">// 单参数构造函数的隐式类型转换</span></span><br><span class=\"line\"><span class=\"comment\">// 用2调用Date构造函数生成一个临时对象，再用这个对象去拷贝构造d4</span></span><br><span class=\"line\"><span class=\"comment\">// 编译器回优化，用2直接构造</span></span><br><span class=\"line\">Date d4 = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> Date&amp; ref = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//有名对象</span></span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d7</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 匿名对象,特点，生命周期只在这一行</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// const引用可以延长匿名对象生命周期</span></span><br><span class=\"line\"><span class=\"type\">const</span> A&amp; ref = <span class=\"built_in\">Date</span>(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// c++11支持多参数的转换</span></span><br><span class=\"line\">Date <span class=\"built_in\">d5</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">Date d6 = &#123;<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>没有显示拷贝构造函数，会生成默认拷贝构造函数</p>\n<p>内置类型，值拷贝</p>\n<p>自定义类型，调用它的拷贝构造函数</p>\n<h4 id=\"取地址重载\"><a class=\"markdownIt-Anchor\" href=\"#取地址重载\">#</a> 取地址重载</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认生成的取地址重载</span></span><br><span class=\"line\">Date* <span class=\"keyword\">operator</span>&amp;() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">const</span> Date* <span class=\"keyword\">operator</span>&amp;() <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 日常自动生成的就可以了，只有不想被取到有效地址时</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重载\"><a class=\"markdownIt-Anchor\" href=\"#重载\">#</a> 重载</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">2023</span>,<span class=\"number\">7</span>,<span class=\"number\">21</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d2</span><span class=\"params\">(<span class=\"number\">2022</span>,<span class=\"number\">8</span>,<span class=\"number\">21</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>,j = <span class=\"number\">2</span>;</span><br><span class=\"line\">i &lt; j;</span><br><span class=\"line\"><span class=\"comment\">// d1 &lt; d2 自定义类型如何比较？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">DateLess</span><span class=\"params\">(<span class=\"type\">const</span> Date&amp; d1,<span class=\"type\">const</span> Date&amp; d2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x1._year &lt; x2._year) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x1._year == x2._year &amp;&amp; x1._month &lt; x2._month) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x1._year == x2._year &amp;&amp; x1._month == x2._month &amp;&amp; x1._day &lt; x2._day) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">DateLess</span>(d1,d2);</span><br><span class=\"line\"><span class=\"comment\">// 但这样不太好，名字可能会比较抽象，并且不够优雅</span></span><br><span class=\"line\"><span class=\"comment\">// 所以c++有了运算符重载</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Date&amp; d1,<span class=\"type\">const</span> Date&amp; d2) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">d1 &lt; d2 等价于 <span class=\"keyword\">operator</span>&lt;(d1,d2)</span><br></pre></td></tr></table></figure>\n<h4 id=\"重载类型\"><a class=\"markdownIt-Anchor\" href=\"#重载类型\">#</a> 重载类型</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">operator</span>+();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>-();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>*();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>/();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>+=();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>-=();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>*=();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>/=();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>++();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>--();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>&lt;&lt;();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>&gt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>[]();</span><br><span class=\"line\"><span class=\"built_in\">operator</span>()();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>&amp;();</span><br></pre></td></tr></table></figure>\n<h4 id=\"特殊重载\"><a class=\"markdownIt-Anchor\" href=\"#特殊重载\">#</a> 特殊 ++ 重载</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++d1 -&gt; d1.<span class=\"keyword\">operator</span>++()</span><br><span class=\"line\"><span class=\"built_in\">operator</span>() &#123;&#125;</span><br><span class=\"line\">d1++ -&gt; d1.<span class=\"keyword\">operator</span>++(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">operator</span>(<span class=\"type\">int</span>) &#123;&#125;<span class=\"comment\">// 可以不接收</span></span><br></pre></td></tr></table></figure>\n<p>只读函数 <code>this</code>  指针可以换加  <code>const</code>  ，内部不涉及修改生成</p>\n<h3 id=\"友元\"><a class=\"markdownIt-Anchor\" href=\"#友元\">#</a> 友元</h3>\n<p>让一个函数或者类访问另一个类中的私有成员<br>\n关键字: <strong>friend</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">goodGay</span><span class=\"params\">(Building &amp;building)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>特点:</strong></p>\n<ol>\n<li>友元函数可以访问类的私有和保护成员，但不是类的成员函数</li>\n<li>友元函数不能用 <code>const</code>  修饰</li>\n<li>友元函数可以在类定义的任何地方声明</li>\n<li>一个函数可以是多个类的友元函数</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部类就是外部类的友元类</span></span><br><span class=\"line\"><span class=\"comment\">// B类受A类域和访问限定符的限制，其实是两个类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            A a;</span><br><span class=\"line\">            a._a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"type\">int</span> _b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化列表构造函数\"><a class=\"markdownIt-Anchor\" href=\"#初始化列表构造函数\">#</a> 初始化列表 (构造函数)</h3>\n<p>初始化列表：以一个<strong>冒号开始</strong>，接着时一个<strong>以逗号分隔的数据成员列表</strong>，每个成员变量后面跟一个<strong>放在括号中的初始值或者表达式。</strong></p>\n<p>初始化列表就是每个成员定义的地方</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day)</span><br><span class=\"line\">        : _year(year)</span><br><span class=\"line\">        , _month(month)</span><br><span class=\"line\">        , _day(day)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 或者</span></span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day)</span><br><span class=\"line\">        : _year(year)</span><br><span class=\"line\">        , _month(month)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _day = day;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化列表是解决这些问题的：</p>\n<ol>\n<li><code>const int _x</code>  ,  <code>int&amp; _y</code>  必须<strong>在定义时进行初始化</strong>，这时方法 2 的初始化就不行了</li>\n<li>没有默认构造的自定义类型，在<strong>定义的时候必须调带参构造</strong></li>\n</ol>\n<h3 id=\"static-静态成员\"><a class=\"markdownIt-Anchor\" href=\"#static-静态成员\">#</a> static - 静态成员</h3>\n<p>它不属于某个对象，属于整个类，存在静态区</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> n;<span class=\"comment\">// 不能给缺省值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> Date::n = <span class=\"number\">0</span>;<span class=\"comment\">// 类外定义</span></span><br></pre></td></tr></table></figure>\n<p><strong>静态函数</strong>：没有  <code>this</code>  指针，所以不能访问非静态成员</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/21/C++/c++%E5%85%A5%E9%97%A8/",
            "url": "http://example.com/2023/07/21/C++/c++%E5%85%A5%E9%97%A8/",
            "title": "c++入门",
            "date_published": "2023-07-21T14:52:20.951Z",
            "content_html": "<h2 id=\"cc的作用领域\"><a class=\"markdownIt-Anchor\" href=\"#cc的作用领域\">#</a> C/c++ 的作用领域</h2>\n<ol>\n<li>操作系统以及大型系统软件开发</li>\n<li>服务器端开发</li>\n<li>游戏开发</li>\n<li>嵌入式和物联网领域</li>\n<li>等等</li>\n</ol>\n<h2 id=\"第一个c程序\"><a class=\"markdownIt-Anchor\" href=\"#第一个c程序\">#</a> 第一个 c++ 程序</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>using namespace std</code>  是命名空间</p>\n<h2 id=\"命名空间\"><a class=\"markdownIt-Anchor\" href=\"#命名空间\">#</a> 命名空间</h2>\n<h3 id=\"为什么要有命名空间\"><a class=\"markdownIt-Anchor\" href=\"#为什么要有命名空间\">#</a> 为什么要有命名空间？</h3>\n<p>我们来看看 c 语言</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,rand);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样程序是可以正常执行的，但是我们加上一个头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,rand);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序就会报错，因为 rand 这个变量和头文件 <code>stdlib.h</code>  里面的变量命名冲突了</p>\n<p>所以在 c 语言中，是存在命名冲突的问题的</p>\n<p>c++ 命名空间就是解决<strong>命名冲突</strong>这个问题的</p>\n<h3 id=\"语法\"><a class=\"markdownIt-Anchor\" href=\"#语法\">#</a> 语法</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> acm &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如何访问命名空间的变量</span></span><br><span class=\"line\">通过 acm::rand</span><br><span class=\"line\"><span class=\"comment\">// ::叫做域作用限定符</span></span><br></pre></td></tr></table></figure>\n<p>默认是在全局查找，不会进入命名空间查找</p>\n<p><code>using namespace acm</code>  会把命名空间全部展开</p>\n<p>展开之后就可以进入里面查找，但这个操作是危险的</p>\n<p>我们可以只展开一部分</p>\n<p><code>using acm::Add</code>  只展开了 Add 函数</p>\n<p>注：同名的命名空间会进行合并，不用担心命名空间名冲突</p>\n<h3 id=\"std\"><a class=\"markdownIt-Anchor\" href=\"#std\">#</a> std</h3>\n<p>std 是 c++ 标准库的命名空间</p>\n<p>头文件 <code>iostream</code>  里面的 <code>cout</code> , <code>endl</code>  等都封装在 std 这个命名空间里面</p>\n<h2 id=\"基础语法\"><a class=\"markdownIt-Anchor\" href=\"#基础语法\">#</a> 基础语法</h2>\n<h3 id=\"coutendl\"><a class=\"markdownIt-Anchor\" href=\"#coutendl\">#</a>  <code>cout</code> , <code>endl</code></h3>\n<p><code>cout</code>  控制台打印，会自动识别类型</p>\n<p><code>endl</code>  可以相当于 \\n</p>\n<h3 id=\"cin-输入\"><a class=\"markdownIt-Anchor\" href=\"#cin-输入\">#</a>  <code>cin</code>  输入</h3>\n<p>cin 可以自动识别类型</p>\n<h3 id=\"流插入运算符\"><a class=\"markdownIt-Anchor\" href=\"#流插入运算符\">#</a> &lt;&lt; 流插入运算符</h3>\n<h3 id=\"流提取\"><a class=\"markdownIt-Anchor\" href=\"#流提取\">#</a>  <code>&gt;&gt;</code>  流提取</h3>\n<h2 id=\"缺省参数\"><a class=\"markdownIt-Anchor\" href=\"#缺省参数\">#</a> 缺省参数</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Func</span><span class=\"params\">(<span class=\"type\">int</span> a = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>int a = 1</code>  就是缺省参数</p>\n<p>如果你不传参数，a 就会等于缺省值，这里是 1</p>\n<p>如果你传了参数，a 就会等于传的值</p>\n<p>缺省又分为全缺省和半缺省</p>\n<p><strong>全缺省</strong>就是全部都是缺省参数</p>\n<p><strong>半缺省</strong>有缺省参数也有普通参数，半缺省必须从右往左给缺省值</p>\n<p>注：声明和定义不能同时给缺省参数</p>\n<h2 id=\"函数重载\"><a class=\"markdownIt-Anchor\" href=\"#函数重载\">#</a> 函数重载</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>c++ 允许在<strong>同一作用域</strong>下声明多个<strong>相同名字的函数</strong>，但这些函数的<strong>形参列表不同</strong>（个数，类型或顺序不同）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1,2类型不同 // 1,3个数不同 //3,4顺序不同，跟名字无关，看的是类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> add)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">double</span> add)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">double</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + (<span class=\"type\">int</span>)right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">double</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)left + right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回值不同不能构成重载</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么c支持函数重载而c语言不支持\"><a class=\"markdownIt-Anchor\" href=\"#为什么c支持函数重载而c语言不支持\">#</a> 为什么 c++ 支持函数重载而 c 语言不支持？</h3>\n<p>过程</p>\n<p>test.cpp</p>\n<p>预处理：头文件展开 / 宏替换 / 去掉注释 / 条件编译</p>\n<p>test.i</p>\n<p>编译：检查语法，生成汇编代码</p>\n<p>test.s</p>\n<p>汇编：将汇编代码生产二进制机器码</p>\n<p>test.o</p>\n<p>链接：合并链接，生成可执行程序</p>\n<p>c 语言是直接用函数名字充当符号表里面的名字</p>\n<p>c++ 则有一套函数名修饰规则，会把类型带进去</p>\n<p>所以函数重载类型不同，个数不同，位置不同，c++ 就可以区分</p>\n<h3 id=\"函数重载和缺省参数一起会导致一个问题\"><a class=\"markdownIt-Anchor\" href=\"#函数重载和缺省参数一起会导致一个问题\">#</a> 函数重载和缺省参数一起会导致一个问题</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 上面两个函数构成重载</span></span><br><span class=\"line\"><span class=\"built_in\">func</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"comment\">// 这样没问题</span></span><br><span class=\"line\"><span class=\"built_in\">func</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 这样就存在歧义了，不知道调哪个函数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c关键字\"><a class=\"markdownIt-Anchor\" href=\"#c关键字\">#</a> c++ 关键字</h2>\n<p>c++ 总计 63 个关键字，c 语言 32 个关键字</p>\n<h2 id=\"引用\"><a class=\"markdownIt-Anchor\" href=\"#引用\">#</a> 引用</h2>\n<p>引用不会新定义一个变量，而是给已存在的变量取一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量公用一片内存空间。</p>\n<h3 id=\"语法-2\"><a class=\"markdownIt-Anchor\" href=\"#语法-2\">#</a> 语法</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; b = a;</span><br><span class=\"line\">cout &lt;&lt; &amp;a &lt;&lt; &amp;b &lt;&lt; endl;<span class=\"comment\">// 输出结果一样</span></span><br><span class=\"line\">b++; <span class=\"comment\">// a也会++</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"特性\"><a class=\"markdownIt-Anchor\" href=\"#特性\">#</a> 特性</h3>\n<ol>\n<li>引用在定义时必须初始化。</li>\n<li>一个变量可以有多个引用。</li>\n<li>引用一旦引用一个实体，不能再引用其他实体（不能再变）。</li>\n</ol>\n<h3 id=\"权限\"><a class=\"markdownIt-Anchor\" href=\"#权限\">#</a> 权限</h3>\n<ul>\n<li>权限可以缩小</li>\n<li>权限可以平移</li>\n<li>权限不能放大</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;b = a; <span class=\"comment\">// 权限的放大，不行</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;c = a;<span class=\"comment\">// 权限的平移</span></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> y = x;<span class=\"comment\">// 权限的缩小</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> &amp;v = x;<span class=\"comment\">// 类型转换时会产生临时对象，临时对象具有常性，不能用double &amp;v接收</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"引用和指针的区别\"><a class=\"markdownIt-Anchor\" href=\"#引用和指针的区别\">#</a> 引用和指针的区别</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *p = &amp;a;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref = a;<span class=\"comment\">// 语法上引用不开空间</span></span><br></pre></td></tr></table></figure>\n<p>但在底层引用是要开空间的，引用是按照指针方式实现的</p>\n<p>区别：</p>\n<ol>\n<li>引用概念上定义一个变量的别名，指针存储一个变量地址</li>\n<li>引用在定义时必须初始化，指针没有要求</li>\n<li>引用在初始化引用一个实体后，不能再引用其他实体，而指针可以指向任何一个同类型实体</li>\n<li>没有 NULL 引用，但有 NULL 指针</li>\n<li>在 <code>sizeof</code>  中含义不同，引用结果为引用类型大小，但指针始终是地址空间所占字节个数</li>\n<li>引用自加即引用的实体增加 1，指针自家即指针向后偏移一个类型大小</li>\n<li>有多级指针，但没有多级引用</li>\n<li>访问实体的方式不同</li>\n<li>引用比指针使用起来跟安全</li>\n</ol>\n<h2 id=\"内联函数\"><a class=\"markdownIt-Anchor\" href=\"#内联函数\">#</a> 内联函数</h2>\n<h3 id=\"宏的缺点\"><a class=\"markdownIt-Anchor\" href=\"#宏的缺点\">#</a> 宏的缺点</h3>\n<p>宏分为宏常量和宏函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 10</span></span><br><span class=\"line\"><span class=\"comment\">// 实现一个ADD的宏函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure>\n<p>可以看见要加很多括号，因为宏本质是一种替换。</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>没有类型的严格限制</li>\n<li>针对频繁调用的小函数，不需要建立栈帧，提高了效率</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>容易出错，语法坑很多</li>\n<li>并且不能调试</li>\n<li>没有类型安全的检查</li>\n</ol>\n<h3 id=\"概念-2\"><a class=\"markdownIt-Anchor\" href=\"#概念-2\">#</a> 概念</h3>\n<p>以 <code>inline</code>  修饰的函数叫做内联函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内联函数会在调用时展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比宏的优点：</p>\n<ol>\n<li>内联也不会建立栈帧</li>\n<li>可以进行调试</li>\n</ol>\n<p>注：内联函数不要声明和定义分离</p>\n<h2 id=\"autoc11\"><a class=\"markdownIt-Anchor\" href=\"#autoc11\">#</a> auto(c++11)</h2>\n<p><code>auto</code>  关键字可以自动推导类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> b = a;<span class=\"comment\">// 通过右边的值自动推导左边的值的类型</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> c = &amp;a;</span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp; d = a;</span><br></pre></td></tr></table></figure>\n<p>当类型很长的时候就可以简化代码。</p>\n<h3 id=\"什么时候使用内联函数\"><a class=\"markdownIt-Anchor\" href=\"#什么时候使用内联函数\">#</a> 什么时候使用内联函数？</h3>\n<p>一般内联机制用于规模较小，流程直接，频繁调用的函数。</p>\n<p>很多编译器也不支持内联递归函数。</p>\n<p>如果内联函数较为复杂，即使加了 <code>inline</code> ，编译器可能也不会把他当作内联函数</p>\n<h2 id=\"范围forc11\"><a class=\"markdownIt-Anchor\" href=\"#范围forc11\">#</a> 范围 for (c++11)</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> array[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 依次取数组中的数据赋值给e</span></span><br><span class=\"line\"><span class=\"comment\">// 自动迭代</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> e : array) &#123;</span><br><span class=\"line\">    cout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"指针空值nullptr\"><a class=\"markdownIt-Anchor\" href=\"#指针空值nullptr\">#</a> 指针空值 nullptr</h2>\n<p>在传统 c 中，NULL 其实是一个宏</p>\n<p><code>#define NULL 0</code></p>\n<p>所以在 c++ 中新定义了一个空指针 <code>nullptr</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">nullptr</span> <span class=\"comment\">// #define nullptr ((void*)0)</span></span><br><span class=\"line\">    <span class=\"comment\">//它所占字节数与(void*)0所占字节大小相同</span></span><br></pre></td></tr></table></figure>\n",
            "tags": []
        }
    ]
}