{
    "version": "https://jsonfeed.org/version/1",
    "title": "汐月也自闭了的个人博客 • All posts by \"c++\" category",
    "description": "这个需求写不了",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/07/21/c++%E5%85%A5%E9%97%A8/",
            "url": "http://example.com/2023/07/21/c++%E5%85%A5%E9%97%A8/",
            "title": "c++入门",
            "date_published": "2023-07-21T14:52:20.951Z",
            "content_html": "<h2 id=\"cc的作用领域\"><a class=\"markdownIt-Anchor\" href=\"#cc的作用领域\">#</a> C/c++ 的作用领域</h2>\n<ol>\n<li>操作系统以及大型系统软件开发</li>\n<li>服务器端开发</li>\n<li>游戏开发</li>\n<li>嵌入式和物联网领域</li>\n<li>等等</li>\n</ol>\n<h2 id=\"第一个c程序\"><a class=\"markdownIt-Anchor\" href=\"#第一个c程序\">#</a> 第一个 c++ 程序</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>using namespace std</code>  是命名空间</p>\n<h2 id=\"命名空间\"><a class=\"markdownIt-Anchor\" href=\"#命名空间\">#</a> 命名空间</h2>\n<h3 id=\"为什么要有命名空间\"><a class=\"markdownIt-Anchor\" href=\"#为什么要有命名空间\">#</a> 为什么要有命名空间？</h3>\n<p>我们来看看 c 语言</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,rand);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样程序是可以正常执行的，但是我们加上一个头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,rand);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序就会报错，因为 rand 这个变量和头文件 <code>stdlib.h</code>  里面的变量命名冲突了</p>\n<p>所以在 c 语言中，是存在命名冲突的问题的</p>\n<p>c++ 命名空间就是解决<strong>命名冲突</strong>这个问题的</p>\n<h3 id=\"语法\"><a class=\"markdownIt-Anchor\" href=\"#语法\">#</a> 语法</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> acm &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如何访问命名空间的变量</span></span><br><span class=\"line\">通过 acm::rand</span><br><span class=\"line\"><span class=\"comment\">// ::叫做域作用限定符</span></span><br></pre></td></tr></table></figure>\n<p>默认是在全局查找，不会进入命名空间查找</p>\n<p><code>using namespace acm</code>  会把命名空间全部展开</p>\n<p>展开之后就可以进入里面查找，但这个操作是危险的</p>\n<p>我们可以只展开一部分</p>\n<p><code>using acm::Add</code>  只展开了 Add 函数</p>\n<p>注：同名的命名空间会进行合并，不用担心命名空间名冲突</p>\n<h3 id=\"std\"><a class=\"markdownIt-Anchor\" href=\"#std\">#</a> std</h3>\n<p>std 是 c++ 标准库的命名空间</p>\n<p>头文件 <code>iostream</code>  里面的 <code>cout</code> , <code>endl</code>  等都封装在 std 这个命名空间里面</p>\n<h2 id=\"基础语法\"><a class=\"markdownIt-Anchor\" href=\"#基础语法\">#</a> 基础语法</h2>\n<h3 id=\"coutendl\"><a class=\"markdownIt-Anchor\" href=\"#coutendl\">#</a>  <code>cout</code> , <code>endl</code></h3>\n<p><code>cout</code>  控制台打印，会自动识别类型</p>\n<p><code>endl</code>  可以相当于 \\n</p>\n<h3 id=\"cin-输入\"><a class=\"markdownIt-Anchor\" href=\"#cin-输入\">#</a>  <code>cin</code>  输入</h3>\n<p>cin 可以自动识别类型</p>\n<h3 id=\"流插入运算符\"><a class=\"markdownIt-Anchor\" href=\"#流插入运算符\">#</a> &lt;&lt; 流插入运算符</h3>\n<h3 id=\"流提取\"><a class=\"markdownIt-Anchor\" href=\"#流提取\">#</a>  <code>&gt;&gt;</code>  流提取</h3>\n<h2 id=\"缺省参数\"><a class=\"markdownIt-Anchor\" href=\"#缺省参数\">#</a> 缺省参数</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Func</span><span class=\"params\">(<span class=\"type\">int</span> a = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>int a = 1</code>  就是缺省参数</p>\n<p>如果你不传参数，a 就会等于缺省值，这里是 1</p>\n<p>如果你传了参数，a 就会等于传的值</p>\n<p>缺省又分为全缺省和半缺省</p>\n<p><strong>全缺省</strong>就是全部都是缺省参数</p>\n<p><strong>半缺省</strong>有缺省参数也有普通参数，半缺省必须从右往左给缺省值</p>\n<p>注：声明和定义不能同时给缺省参数</p>\n<h2 id=\"函数重载\"><a class=\"markdownIt-Anchor\" href=\"#函数重载\">#</a> 函数重载</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>c++ 允许在<strong>同一作用域</strong>下声明多个<strong>相同名字的函数</strong>，但这些函数的<strong>形参列表不同</strong>（个数，类型或顺序不同）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1,2类型不同 // 1,3个数不同 //3,4顺序不同，跟名字无关，看的是类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> add)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">double</span> add)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">double</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + (<span class=\"type\">int</span>)right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">double</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)left + right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回值不同不能构成重载</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么c支持函数重载而c语言不支持\"><a class=\"markdownIt-Anchor\" href=\"#为什么c支持函数重载而c语言不支持\">#</a> 为什么 c++ 支持函数重载而 c 语言不支持？</h3>\n<p>过程</p>\n<p>test.cpp</p>\n<p>预处理：头文件展开 / 宏替换 / 去掉注释 / 条件编译</p>\n<p>test.i</p>\n<p>编译：检查语法，生成汇编代码</p>\n<p>test.s</p>\n<p>汇编：将汇编代码生产二进制机器码</p>\n<p>test.o</p>\n<p>链接：合并链接，生成可执行程序</p>\n<p>c 语言是直接用函数名字充当符号表里面的名字</p>\n<p>c++ 则有一套函数名修饰规则，会把类型带进去</p>\n<p>所以函数重载类型不同，个数不同，位置不同，c++ 就可以区分</p>\n<h3 id=\"函数重载和缺省参数一起会导致一个问题\"><a class=\"markdownIt-Anchor\" href=\"#函数重载和缺省参数一起会导致一个问题\">#</a> 函数重载和缺省参数一起会导致一个问题</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 上面两个函数构成重载</span></span><br><span class=\"line\"><span class=\"built_in\">func</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"comment\">// 这样没问题</span></span><br><span class=\"line\"><span class=\"built_in\">func</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 这样就存在歧义了，不知道调哪个函数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c关键字\"><a class=\"markdownIt-Anchor\" href=\"#c关键字\">#</a> c++ 关键字</h2>\n<p>c++ 总计 63 个关键字，c 语言 32 个关键字</p>\n<h2 id=\"引用\"><a class=\"markdownIt-Anchor\" href=\"#引用\">#</a> 引用</h2>\n<p>引用不会新定义一个变量，而是给已存在的变量取一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量公用一片内存空间。</p>\n<h3 id=\"语法-2\"><a class=\"markdownIt-Anchor\" href=\"#语法-2\">#</a> 语法</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; b = a;</span><br><span class=\"line\">cout &lt;&lt; &amp;a &lt;&lt; &amp;b &lt;&lt; endl;<span class=\"comment\">// 输出结果一样</span></span><br><span class=\"line\">b++; <span class=\"comment\">// a也会++</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"特性\"><a class=\"markdownIt-Anchor\" href=\"#特性\">#</a> 特性</h3>\n<ol>\n<li>引用在定义时必须初始化。</li>\n<li>一个变量可以有多个引用。</li>\n<li>引用一旦引用一个实体，不能再引用其他实体（不能再变）。</li>\n</ol>\n<h3 id=\"权限\"><a class=\"markdownIt-Anchor\" href=\"#权限\">#</a> 权限</h3>\n<ul>\n<li>权限可以缩小</li>\n<li>权限可以平移</li>\n<li>权限不能放大</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;b = a; <span class=\"comment\">// 权限的放大，不行</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;c = a;<span class=\"comment\">// 权限的平移</span></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> y = x;<span class=\"comment\">// 权限的缩小</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> &amp;v = x;<span class=\"comment\">// 类型转换时会产生临时对象，临时对象具有常性，不能用double &amp;v接收</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"引用和指针的区别\"><a class=\"markdownIt-Anchor\" href=\"#引用和指针的区别\">#</a> 引用和指针的区别</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *p = &amp;a;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref = a;<span class=\"comment\">// 语法上引用不开空间</span></span><br></pre></td></tr></table></figure>\n<p>但在底层引用是要开空间的，引用是按照指针方式实现的</p>\n<p>区别：</p>\n<ol>\n<li>引用概念上定义一个变量的别名，指针存储一个变量地址</li>\n<li>引用在定义时必须初始化，指针没有要求</li>\n<li>引用在初始化引用一个实体后，不能再引用其他实体，而指针可以指向任何一个同类型实体</li>\n<li>没有 NULL 引用，但有 NULL 指针</li>\n<li>在 <code>sizeof</code>  中含义不同，引用结果为引用类型大小，但指针始终是地址空间所占字节个数</li>\n<li>引用自加即引用的实体增加 1，指针自家即指针向后偏移一个类型大小</li>\n<li>有多级指针，但没有多级引用</li>\n<li>访问实体的方式不同</li>\n<li>引用比指针使用起来跟安全</li>\n</ol>\n<h2 id=\"内联函数\"><a class=\"markdownIt-Anchor\" href=\"#内联函数\">#</a> 内联函数</h2>\n<h3 id=\"宏的缺点\"><a class=\"markdownIt-Anchor\" href=\"#宏的缺点\">#</a> 宏的缺点</h3>\n<p>宏分为宏常量和宏函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 10</span></span><br><span class=\"line\"><span class=\"comment\">// 实现一个ADD的宏函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure>\n<p>可以看见要加很多括号，因为宏本质是一种替换。</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>没有类型的严格限制</li>\n<li>针对频繁调用的小函数，不需要建立栈帧，提高了效率</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>容易出错，语法坑很多</li>\n<li>并且不能调试</li>\n<li>没有类型安全的检查</li>\n</ol>\n<h3 id=\"概念-2\"><a class=\"markdownIt-Anchor\" href=\"#概念-2\">#</a> 概念</h3>\n<p>以 <code>inline</code>  修饰的函数叫做内联函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内联函数会在调用时展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比宏的优点：</p>\n<ol>\n<li>内联也不会建立栈帧</li>\n<li>可以进行调试</li>\n</ol>\n<p>注：内联函数不要声明和定义分离</p>\n<h2 id=\"autoc11\"><a class=\"markdownIt-Anchor\" href=\"#autoc11\">#</a> auto(c++11)</h2>\n<p><code>auto</code>  关键字可以自动推导类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> b = a;<span class=\"comment\">// 通过右边的值自动推导左边的值的类型</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> c = &amp;a;</span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp; d = a;</span><br></pre></td></tr></table></figure>\n<p>当类型很长的时候就可以简化代码。</p>\n<h3 id=\"什么时候使用内联函数\"><a class=\"markdownIt-Anchor\" href=\"#什么时候使用内联函数\">#</a> 什么时候使用内联函数？</h3>\n<p>一般内联机制用于规模较小，流程直接，频繁调用的函数。</p>\n<p>很多编译器也不支持内联递归函数。</p>\n<p>如果内联函数较为复杂，即使加了 <code>inline</code> ，编译器可能也不会把他当作内联函数</p>\n<h2 id=\"范围forc11\"><a class=\"markdownIt-Anchor\" href=\"#范围forc11\">#</a> 范围 for (c++11)</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> array[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 依次取数组中的数据赋值给e</span></span><br><span class=\"line\"><span class=\"comment\">// 自动迭代</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> e : array) &#123;</span><br><span class=\"line\">    cout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"指针空值nullptr\"><a class=\"markdownIt-Anchor\" href=\"#指针空值nullptr\">#</a> 指针空值 nullptr</h2>\n<p>在传统 c 中，NULL 其实是一个宏</p>\n<p><code>#define NULL 0</code></p>\n<p>所以在 c++ 中新定义了一个空指针 <code>nullptr</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">nullptr</span> <span class=\"comment\">// #define nullptr ((void*)0)</span></span><br><span class=\"line\">    <span class=\"comment\">//它所占字节数与(void*)0所占字节大小相同</span></span><br></pre></td></tr></table></figure>\n",
            "tags": []
        }
    ]
}