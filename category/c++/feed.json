{
    "version": "https://jsonfeed.org/version/1",
    "title": "汐月也自闭了的个人博客 • All posts by \"c++\" category",
    "description": "这个需求写不了",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/27/C++/string%E7%B1%BB%E5%8F%8A%E5%85%B6%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/",
            "url": "http://example.com/2023/08/27/C++/string%E7%B1%BB%E5%8F%8A%E5%85%B6%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/",
            "title": "string类及其模拟实现",
            "date_published": "2023-08-27T09:11:07.344Z",
            "content_html": "<h3 id=\"string类\"><a class=\"markdownIt-Anchor\" href=\"#string类\">#</a> string 类</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 底层</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> basic_string&lt;<span class=\"type\">char</span>&gt; string;</span><br></pre></td></tr></table></figure>\n<p><code>string</code>  是表示字符串的字符串类</p>\n<p>该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作 string 的常规操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s1;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s2</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>)</span></span>;</span><br><span class=\"line\">string s3 = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// string(const string&amp; str,size_t pos,size_t size);</span></span><br><span class=\"line\"><span class=\"comment\">// 用str的pos开始，size那么长的部分去构造</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s4</span><span class=\"params\">(<span class=\"string\">&quot;hello&quot;</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>)</span></span>;<span class=\"comment\">// &quot;h&quot;</span></span><br><span class=\"line\">cin &gt;&gt; s1;</span><br><span class=\"line\">string ret1 = s1 + s2;</span><br><span class=\"line\">string ret2 = s1 + <span class=\"string\">&quot;我来了&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"string类对象的容量操作\"><a class=\"markdownIt-Anchor\" href=\"#string类对象的容量操作\">#</a> string 类对象的容量操作</h4>\n<table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>size</strong></td>\n<td><strong>返回字符串有效字符长度</strong></td>\n</tr>\n<tr>\n<td><strong>length</strong></td>\n<td><strong>返回字符串有效字符长度</strong></td>\n</tr>\n<tr>\n<td><strong>capacity</strong></td>\n<td><strong>返回空间总大小</strong></td>\n</tr>\n<tr>\n<td><strong>empty</strong></td>\n<td><strong>检测字符串释放为空串，是返回</strong> true**，否则返回 **false</td>\n</tr>\n<tr>\n<td><strong>clear</strong></td>\n<td><strong>清空有效字符</strong></td>\n</tr>\n<tr>\n<td><strong>reserve</strong></td>\n<td><strong>为字符串预留空间</strong></td>\n</tr>\n<tr>\n<td><strong>resize</strong></td>\n<td><strong>将有效字符的个数改成</strong> n 个，多出的空间用字符 c<strong> 填充</strong></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><code>size()</code>  与 <code>length()</code>  方法底层实现原理完全相同，引入 size () 的原因是为了与其他容器的接口保持一</li>\n</ol>\n<p>致，一般情况下基本都是用 size ()。</p>\n<ol start=\"2\">\n<li>\n<p><code>clear()</code>  只是将 string 中有效字符清空，不改变底层空间大小。</p>\n</li>\n<li>\n<p><code>resize(size_t n) </code> 与  <code>resize(size_t n, char c)</code>  都是将字符串中有效字符个数改变到 n 个，不同的是当字</p>\n</li>\n</ol>\n<p>符个数增多时： <code>resize(n)</code>  用 0 来填充多出的元素空间， <code>resize(size_t n, char c)</code>  用字符 c 来填充多出的</p>\n<p>元素空间。注意：resize 在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大</p>\n<p>小，如果是将元素个数减少，底层空间总大小不变。</p>\n<ol start=\"4\">\n<li><code>reserve(size_t res_arg=0)</code> ：为 string 预留空间，不改变有效元素个数，当 reserve 的参数小于</li>\n</ol>\n<p>string 的底层空间总大小时，reserver 不会改变容量大小。</p>\n<h4 id=\"string类对象的访问及遍历操作\"><a class=\"markdownIt-Anchor\" href=\"#string类对象的访问及遍历操作\">#</a> <strong>string</strong> 类对象的访问及遍历操作</h4>\n<table>\n<thead>\n<tr>\n<th><strong>函数名称</strong></th>\n<th><strong>功能说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>operator[]</strong></td>\n<td>返回<strong> pos</strong> 位置的字符，<strong>const string</strong> 类对象调用</td>\n</tr>\n<tr>\n<td><strong>begin</strong>+ <strong>end</strong></td>\n<td><strong>begin</strong> 获取一个字符的迭代器 + <strong>end</strong> 获取最后一个字符下一个位置的迭代器</td>\n</tr>\n<tr>\n<td>范围<strong> for</strong></td>\n<td><strong>C++11</strong> 支持更简洁的范围<strong> for</strong> 的新遍历方式</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"string类对象的修改操作\"><a class=\"markdownIt-Anchor\" href=\"#string类对象的修改操作\">#</a> <strong>string</strong> 类对象的修改操作</h4>\n<table>\n<thead>\n<tr>\n<th><strong>函数名称</strong></th>\n<th><strong>功能说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>push_back</strong></td>\n<td>在字符串后尾插字符<strong> c</strong></td>\n</tr>\n<tr>\n<td><strong>append</strong></td>\n<td><strong>在字符串后追加一个字符串</strong></td>\n</tr>\n<tr>\n<td><strong>operator+=</strong></td>\n<td>在字符串后追加字符串<strong> str</strong></td>\n</tr>\n<tr>\n<td><strong>c_str</strong></td>\n<td>返回<strong> C</strong> 格式字符串</td>\n</tr>\n<tr>\n<td><strong>find</strong> + <strong>npos</strong></td>\n<td>从字符串<strong> pos</strong> 位置开始往后找字符<strong> c</strong>，返回该字符在字符串中的位置</td>\n</tr>\n<tr>\n<td><strong>rfind</strong></td>\n<td>从字符串<strong> pos</strong> 位置开始往前找字符<strong> c</strong>，返回该字符在字符串中的位置</td>\n</tr>\n<tr>\n<td><strong>substr</strong></td>\n<td>在<strong> str</strong> 中从<strong> pos</strong> 位置开始，截取<strong> n</strong> 个字符，然后将其返回</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"迭代器-iterators\"><a class=\"markdownIt-Anchor\" href=\"#迭代器-iterators\">#</a> 迭代器 - Iterators</h3>\n<table>\n<thead>\n<tr>\n<th><strong>函数名</strong></th>\n<th><strong>功能说明</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>begin</strong></td>\n<td>返回开始位置的迭代器 (返回类型 iterator or const_iterator)</td>\n</tr>\n<tr>\n<td><strong>end</strong></td>\n<td>返回结束位置的迭代器 (返回类型 iterator or const_iterator)</td>\n</tr>\n<tr>\n<td><strong>rbegin</strong></td>\n<td>返回反转开始位置的迭代器 (返回类型 reverse_iterator)</td>\n</tr>\n<tr>\n<td><strong>rend</strong></td>\n<td>返回反转结束位置的迭代器 (返回类型 reverse_iterator)</td>\n</tr>\n<tr>\n<td><strong>cbegin</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>cend</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>crbegin</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>crend</strong></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s1 = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 迭代器是一个像指针一样的东西</span></span><br><span class=\"line\"><span class=\"comment\">// 如果s1是const的，那返回就是string::const_iterator</span></span><br><span class=\"line\">string::iterator it = s1.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it != s1.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">    cout &lt;&lt; *it &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"string-模拟实现\"><a class=\"markdownIt-Anchor\" href=\"#string-模拟实现\">#</a> string 模拟实现</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> mystring &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">typedef</span> <span class=\"type\">char</span>* iterator;</span><br><span class=\"line\">\t\t<span class=\"keyword\">typedef</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* const_iterator;</span><br><span class=\"line\">\t\t<span class=\"function\">iterator <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\">iterator <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _str + _size;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\">const_iterator <span class=\"title\">begin</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\">const_iterator <span class=\"title\">end</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _str + _size;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// init</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">string</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* str = <span class=\"string\">&quot;&quot;</span>)<span class=\"comment\">// default bring&#x27;\\0&#x27;</span></span><br><span class=\"line\">\t\t\t:_size(<span class=\"built_in\">strlen</span>(str))</span><br><span class=\"line\">\t\t\t,_capacity(_size + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t_str = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[_capacity + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">strcpy</span>(_str, str);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(string&amp; s)</span> </span>&#123;</span><br><span class=\"line\">\t\t\tstd::<span class=\"built_in\">swap</span>(_str, s._str);</span><br><span class=\"line\">\t\t\tstd::<span class=\"built_in\">swap</span>(_size, s._size);</span><br><span class=\"line\">\t\t\tstd::<span class=\"built_in\">swap</span>(_capacity, s._capacity);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 拷贝构造</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">string</span>(<span class=\"type\">const</span> string&amp; s)</span><br><span class=\"line\">\t\t\t:_str(<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t,_size(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t,_capacity(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\">string <span class=\"title\">tmp</span><span class=\"params\">(s._str)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(tmp);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstring&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> string&amp; s) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;s) &#123;</span><br><span class=\"line\">\t\t\t\tstring <span class=\"built_in\">tmp</span>(s);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">swap</span>(tmp);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstring&amp; <span class=\"keyword\">operator</span>=(string&amp; s) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">swap</span>(s);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _size;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">capacity</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _capacity;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">char</span> ch, <span class=\"type\">size_t</span> pos = <span class=\"number\">0</span>)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = pos; i &lt; _size; i++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (_str[i] == ch) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> npos;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* sub, <span class=\"type\">size_t</span> pos = <span class=\"number\">0</span>)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// bm算法 子串匹配</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> <span class=\"type\">char</span>* p = <span class=\"built_in\">strstr</span>(_str + pos, sub);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> p - _str;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> npos;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\">string <span class=\"title\">substr</span><span class=\"params\">(<span class=\"type\">size_t</span> pos, <span class=\"type\">size_t</span> len = npos)</span> </span>&#123;</span><br><span class=\"line\">\t\t\tstring s;</span><br><span class=\"line\">\t\t\t<span class=\"type\">size_t</span> end = pos + len;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (len == npos || end &gt;= _size) &#123;</span><br><span class=\"line\">\t\t\t\tend = _size;</span><br><span class=\"line\">\t\t\t\ts.<span class=\"built_in\">reserve</span>(len);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = pos; i &lt; end; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\ts += _str[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\ts.<span class=\"built_in\">reserve</span>(len);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = pos; i &lt; end; i++) &#123;</span><br><span class=\"line\">\t\t\t\t\ts += _str[i];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// read and write version</span></span><br><span class=\"line\">\t\t<span class=\"type\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">size_t</span> pos) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(pos &lt; _size);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _str[pos];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// only read version</span></span><br><span class=\"line\">\t\t<span class=\"type\">const</span> <span class=\"type\">char</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">size_t</span> pos) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(pos &lt; _size);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _str[pos];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">c_str</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> _str;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reserve</span><span class=\"params\">(<span class=\"type\">size_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n &gt; _capacity) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">char</span>* tmp = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">strcpy</span>(tmp, _str);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">delete</span>[] _str;</span><br><span class=\"line\">\t\t\t\t_str = tmp;</span><br><span class=\"line\">\t\t\t\t_capacity = n;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"type\">char</span> ch)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_size == _capacity) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">reserve</span>(_capacity == <span class=\"number\">0</span> ? <span class=\"number\">4</span> :_capacity * <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_str[_size] = ch;</span><br><span class=\"line\">\t\t\t++_size;</span><br><span class=\"line\">\t\t\t_str[_size] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* str)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">size_t</span> len = <span class=\"built_in\">strlen</span>(str);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_size + len &gt; _capacity) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">reserve</span>(_size + len);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">strcpy</span>(_str + _size, str);</span><br><span class=\"line\">\t\t\t_size += len;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">size_t</span> pos, <span class=\"type\">char</span> ch)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(pos &lt;= _size);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_size == _capacity) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">reserve</span>(_capacity == <span class=\"number\">0</span> ? <span class=\"number\">4</span> : _capacity * <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"type\">size_t</span> end = _size + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (end &gt; pos) &#123;</span><br><span class=\"line\">\t\t\t\t_str[end] = _str[end - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\t--end;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t_str[pos] = ch;</span><br><span class=\"line\">\t\t\t_size++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">size_t</span> pos, <span class=\"type\">const</span> <span class=\"type\">char</span>* str)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(pos &lt;= _size);</span><br><span class=\"line\">\t\t\t<span class=\"type\">size_t</span> len = <span class=\"built_in\">strlen</span>(str);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (_size + len &gt; _capacity) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">reserve</span>(_size + len);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"type\">size_t</span> end = _size + len;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (end &gt; pos + len - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t_str[end] = _str[end - len];</span><br><span class=\"line\">\t\t\t\t--end;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"type\">char</span> s = _str[pos + len];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">strcpy</span>(_str + pos,str);</span><br><span class=\"line\">\t\t\t_str[pos + len] = s;</span><br><span class=\"line\">\t\t\t_size+= len;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">size_t</span> pos, <span class=\"type\">size_t</span> len = npos)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">assert</span>(pos &lt; _size);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (len == npos || pos + len &gt;= _size) &#123;</span><br><span class=\"line\">\t\t\t\t_str[pos] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t_size = pos;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">size_t</span> begin = pos + len;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (begin &lt;= _size) &#123;</span><br><span class=\"line\">\t\t\t\t\t_str[begin - len] = _str[begin];</span><br><span class=\"line\">\t\t\t\t\t++begin;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t_size -= len;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"type\">size_t</span> n, <span class=\"type\">char</span> c = <span class=\"string\">&#x27;\\0&#x27;</span>)</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n &lt;= _size) &#123;</span><br><span class=\"line\">\t\t\t\t_str[n] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t_size = n;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">reserve</span>(n);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (_size &lt; n) &#123;</span><br><span class=\"line\">\t\t\t\t\t_str[_size] = c;</span><br><span class=\"line\">\t\t\t\t\t++_size;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t_str[_size] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// base</span></span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> string&amp; s) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(_str, s._str) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> string&amp; s) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(_str, s._str) == <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// use base</span></span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;=(<span class=\"type\">const</span> string&amp; s) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span> &lt; s || *<span class=\"keyword\">this</span> == s;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> string&amp; s) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> !(*<span class=\"keyword\">this</span> &lt;= s);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;=(<span class=\"type\">const</span> string&amp; s) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> !(*<span class=\"keyword\">this</span> &lt; s);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>!=(<span class=\"type\">const</span> string&amp; s) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> !(*<span class=\"keyword\">this</span> == s);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tstring&amp; <span class=\"keyword\">operator</span>+=(<span class=\"type\">char</span> ch) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">push_back</span>(ch);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstring&amp; <span class=\"keyword\">operator</span>+=(<span class=\"type\">const</span> <span class=\"type\">char</span>* str) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">append</span>(str);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t_str[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t\t\t_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test_string1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\">string <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">&quot;hello world&quot;</span>)</span></span>;</span><br><span class=\"line\">\t\t\ts1.<span class=\"built_in\">insert</span>(<span class=\"number\">11</span>, <span class=\"string\">&quot;qwe&quot;</span>);</span><br><span class=\"line\">\t\t\tcout &lt;&lt; s1.<span class=\"built_in\">c_str</span>() &lt;&lt; endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t~<span class=\"built_in\">string</span>() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span>[] _str;</span><br><span class=\"line\">\t\t\t_str = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t_size = _capacity = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t\t<span class=\"type\">char</span>* _str;</span><br><span class=\"line\">\t\t<span class=\"type\">size_t</span> _size;</span><br><span class=\"line\">\t\t<span class=\"type\">size_t</span> _capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">const</span> <span class=\"type\">static</span> <span class=\"type\">size_t</span> npos;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">size_t</span> string::npos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"type\">const</span> string&amp; s) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/*for (size_t i = 0; i &lt; s.size(); i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tout &lt;&lt; s[i];</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&#125;*/</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> ch : s) &#123;</span><br><span class=\"line\">\t\t\tout &lt;&lt; ch;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> out;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tistream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; in, string&amp; s) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> ch;</span><br><span class=\"line\">\t\t<span class=\"comment\">// if in == cin, ch can&#x27;t get &#x27; &#x27; or &#x27;\\n&#x27;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//in &gt;&gt; ch;</span></span><br><span class=\"line\">\t\ts.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> buff[<span class=\"number\">129</span>];</span><br><span class=\"line\">\t\t<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tch = in.<span class=\"built_in\">get</span>();<span class=\"comment\">// one by one get including &#x27; &#x27; and &#x27;\\n&#x27;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ch != <span class=\"string\">&#x27; &#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\tbuff[i++] = ch;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == <span class=\"number\">128</span>) &#123;</span><br><span class=\"line\">\t\t\t\tbuff[i] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t\t\t\ts += buff;</span><br><span class=\"line\">\t\t\t\ti = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tch = in.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tbuff[i] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">\t\t\ts += buff;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> in;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/08/06/C++/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/",
            "url": "http://example.com/2023/08/06/C++/c++%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/",
            "title": "c++类和对象",
            "date_published": "2023-08-05T16:15:21.472Z",
            "content_html": "<h2 id=\"类\"><a class=\"markdownIt-Anchor\" href=\"#类\">#</a> 类</h2>\n<p>c++ 是基于面向对象，但不是纯面向对象的语言，它可以面向对象与面向过程一起写。</p>\n<p>结构体升级成了类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">c</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"comment\">// c++里面的结构体可以定义成员函数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> b[<span class=\"number\">10</span>];<span class=\"comment\">// 成员变量</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">a</span> s1; <span class=\"comment\">// 兼容c</span></span><br><span class=\"line\">a s2; <span class=\"comment\">// c++可以直接定义</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"语法\"><a class=\"markdownIt-Anchor\" href=\"#语法\">#</a> 语法</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">className</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>类成员变量是每一个实例对象分别有的</p>\n<p>但类成员函数是公有的，有一个类成员函数表</p>\n<h3 id=\"访问限定符\"><a class=\"markdownIt-Anchor\" href=\"#访问限定符\">#</a> 访问限定符</h3>\n<p><code>public</code> , <code>private</code> , <code>protected</code></p>\n<ol>\n<li><code>public</code>  修饰的成员在类外可以直接被范围跟</li>\n<li><code>private</code>  和 <code>protected</code>  修饰的成员在类外不能直接被访问</li>\n<li>class 默认访问权限为 <code>private</code> ， <code>struct</code>  为 <code>public</code></li>\n</ol>\n<h3 id=\"计算类或对象大小\"><a class=\"markdownIt-Anchor\" href=\"#计算类或对象大小\">#</a> 计算类或对象大小</h3>\n<p>在底层都是按类进行计算</p>\n<p>可以通过 <code>sizeof</code>  进行计算，计算时不会算成员函数占的空间</p>\n<p>所以类的大小就是成员变量的大小，当然要注意内存对齐</p>\n<p>空类给了一个字节作为表示。</p>\n<h3 id=\"this指针\"><a class=\"markdownIt-Anchor\" href=\"#this指针\">#</a> this 指针</h3>\n<p>类型:  <code>类型* const</code></p>\n<p>this 指向调用函数的实例对象。</p>\n<p>类中成员函数会隐式添加一个 this 指针，但它在实参和形参位置不能显式写，</p>\n<p>但在类里面可以显式的用.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 编译后 void Init(Date* const this, int year);</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init</span><span class=\"params\">(<span class=\"type\">int</span> year)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this-&gt;_year = year;</span></span><br><span class=\"line\">        <span class=\"comment\">//在成员变量前面编译器会自动加this</span></span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 编译后 void Init(const Date* const this, int year);</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init1</span><span class=\"params\">(<span class=\"type\">int</span> year)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// this-&gt;_year = year;</span></span><br><span class=\"line\">        <span class=\"comment\">//在成员变量前面编译器会自动加this</span></span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> year;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"this指针存在哪\"><a class=\"markdownIt-Anchor\" href=\"#this指针存在哪\">#</a> this 指针存在哪？</h4>\n<p>this 指针是一个形参，一般时存在栈帧里面</p>\n<p>vs 下面一般会用 <code>ecx</code>  寄存器直接传递</p>\n<h3 id=\"内置类型与自定义类型\"><a class=\"markdownIt-Anchor\" href=\"#内置类型与自定义类型\">#</a> 内置类型与自定义类型</h3>\n<p>内置类型时语言提供的数据类型，如：int/char，指针都是内置类型</p>\n<p>自定义类型就是我们使用 <code>class</code> / <code>struct</code> / <code>union</code>  等自己定义的类型</p>\n<h3 id=\"类的6个默认成员函数\"><a class=\"markdownIt-Anchor\" href=\"#类的6个默认成员函数\">#</a> 类的 6 个默认成员函数</h3>\n<p>初始化和清理：<strong>构造函数</strong>主要完成<strong>初始化</strong>工作，<strong>析构函数</strong>主要完成<strong>清理</strong>工作</p>\n<p>拷贝复制：<strong>拷贝构造</strong>时使用同类对象初始化创建对象，<strong>赋值重载</strong>主要时把一个对象赋值给另一个对象</p>\n<p>取地址重载：主要是普通对象和 <code>const</code>  对象取地址</p>\n<p>默认成员函数我们不写，编译器会自动生成。</p>\n<p>我们写了就不会生成了。</p>\n<h4 id=\"构造函数\"><a class=\"markdownIt-Anchor\" href=\"#构造函数\">#</a> 构造函数</h4>\n<p>构造函数时<strong>特殊的成员函数</strong>，需要注意的是，构造函数虽然名叫构造，但是构造函数的主要任务<strong>并不是开空间创建对象，而是初始化对象</strong>。</p>\n<p>特征如下：</p>\n<ol>\n<li>函数名与类名相同。</li>\n<li>无返回值。(不需要写 <code>void</code> )</li>\n<li>对象实例化时编译器<strong>自动调动</strong>对应的构造函数。</li>\n<li>构造函数可以重载。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>() &#123;</span><br><span class=\"line\">        _year = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year) &#123;</span><br><span class=\"line\">        _year = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> _year;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 无参构造调用</span></span><br><span class=\"line\">Date d2;</span><br><span class=\"line\"><span class=\"comment\">//有参构造调用</span></span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d2</span><span class=\"params\">(<span class=\"number\">2023</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>编译生成的默认构造的特点：</p>\n<ol>\n<li>我们不写才会生成，写了任意一个构造函数就不会生成</li>\n<li>内置类型的成员不会处理 (c++11 支持声明给缺省值)</li>\n<li>自定义类型成员才会处理，回去调用这个成员的<strong>构造函数</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> _year = <span class=\"number\">1</span>;<span class=\"comment\">// 声明给的缺省值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>无参的构造函数</strong>和<strong>全缺省的构造函数</strong>都叫做默认构造函数，但只能存在一个</p>\n<p>** 总结：** 一般情况都需要自己写，如果成员全是自定义类型可以考虑不写</p>\n<h4 id=\"析构函数\"><a class=\"markdownIt-Anchor\" href=\"#析构函数\">#</a> 析构函数</h4>\n<p>与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作由编译器完成，而<strong>对象在销毁时会自动调用析构函数，完成对对象中资源的清理工作。</strong></p>\n<p>特征如下：</p>\n<ol>\n<li>析构函数名实在类名前面加上字符 <code>~</code> 。</li>\n<li>无参数无返回类型。</li>\n<li>一个类只能有一个析构函数，如果没有显式定义，系统会自动生成默认的析构函数。析构函数不能重载。</li>\n<li>对象生命周期结束时，c++ 编译系统自动调用析构函数。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Date</span>() &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;~Date()&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 析构函数后定义，先调用</span></span><br><span class=\"line\">Date s1;</span><br><span class=\"line\">Date s2;</span><br><span class=\"line\"><span class=\"comment\">// 先调用s2的析构函数</span></span><br></pre></td></tr></table></figure>\n<p>编译生成的默认析构函数特点与默认构造函数类似：</p>\n<ol>\n<li>内置类型的成员不会处理 (c++11 支持声明给缺省值)</li>\n<li>自定义类型成员才会处理，回去调用这个成员的<strong>构造函数</strong></li>\n</ol>\n<h4 id=\"拷贝构造函数\"><a class=\"markdownIt-Anchor\" href=\"#拷贝构造函数\">#</a> 拷贝构造函数</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year = <span class=\"number\">1</span>,<span class=\"type\">int</span> month = <span class=\"number\">1</span>,<span class=\"type\">int</span> day = <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">        _month = month;</span><br><span class=\"line\">        _day = day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _year = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">    <span class=\"type\">int</span> _day;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">2023</span>,<span class=\"number\">7</span>,<span class=\"number\">21</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>正常拷贝没有问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">(Date d)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// d是d1的浅拷贝（直接拷贝）;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但如果里面有在堆里面的空间，并且我们是在析构函数中释放它时</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当func1结束时</span></span><br><span class=\"line\"><span class=\"comment\">// d会先调用析构，释放该片空间</span></span><br><span class=\"line\"><span class=\"comment\">// d1再调用析构，就会报错</span></span><br></pre></td></tr></table></figure>\n<p>解决方法：</p>\n<ol>\n<li>引用 <code>void func1(Date&amp; d)</code> , 但并不好，在里面更改 d 会影响 d1</li>\n<li>拷贝构造函数</li>\n</ol>\n<p><strong>特征：</strong></p>\n<ul>\n<li>拷贝构造函数是<strong>构造函数的一个重载形式</strong>。</li>\n<li>拷贝构造好书的参数<strong>只有一个</strong>且必须是<strong>同类型对象的引用 (const 修饰)</strong>，使用<strong>传值方式编译器直接报错</strong>，因为会引发无穷递归调用 (如果传值，值又是一个实例对象，又要调拷贝构造，又要传值，就会无限递归)。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year = <span class=\"number\">1</span>,<span class=\"type\">int</span> month = <span class=\"number\">1</span>,<span class=\"type\">int</span> day = <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        _year = year;</span><br><span class=\"line\">        _month = month;</span><br><span class=\"line\">        _day = day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(Date&amp; d) &#123;</span><br><span class=\"line\">        _year = d.year;</span><br><span class=\"line\">        _month = d.month;</span><br><span class=\"line\">        _day = d.day;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _year = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> _month;</span><br><span class=\"line\">    <span class=\"type\">int</span> _day;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"拷贝构造语法\"><a class=\"markdownIt-Anchor\" href=\"#拷贝构造语法\">#</a> <strong>拷贝构造语法：</strong></h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d2</span><span class=\"params\">(d1)</span></span>;</span><br><span class=\"line\">Date d3 = d1;</span><br><span class=\"line\"><span class=\"comment\">// 单参数构造函数的隐式类型转换</span></span><br><span class=\"line\"><span class=\"comment\">// 用2调用Date构造函数生成一个临时对象，再用这个对象去拷贝构造d4</span></span><br><span class=\"line\"><span class=\"comment\">// 编译器回优化，用2直接构造</span></span><br><span class=\"line\">Date d4 = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> Date&amp; ref = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">//有名对象</span></span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d7</span><span class=\"params\">(<span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 匿名对象,特点，生命周期只在这一行</span></span><br><span class=\"line\"><span class=\"built_in\">Date</span>(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// const引用可以延长匿名对象生命周期</span></span><br><span class=\"line\"><span class=\"type\">const</span> A&amp; ref = <span class=\"built_in\">Date</span>(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// c++11支持多参数的转换</span></span><br><span class=\"line\">Date <span class=\"built_in\">d5</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">Date d6 = &#123;<span class=\"number\">2</span>,<span class=\"number\">2</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>没有显示拷贝构造函数，会生成默认拷贝构造函数</p>\n<p>内置类型，值拷贝</p>\n<p>自定义类型，调用它的拷贝构造函数</p>\n<h4 id=\"取地址重载\"><a class=\"markdownIt-Anchor\" href=\"#取地址重载\">#</a> 取地址重载</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认生成的取地址重载</span></span><br><span class=\"line\">Date* <span class=\"keyword\">operator</span>&amp;() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">const</span> Date* <span class=\"keyword\">operator</span>&amp;() <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 日常自动生成的就可以了，只有不想被取到有效地址时</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"重载\"><a class=\"markdownIt-Anchor\" href=\"#重载\">#</a> 重载</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d1</span><span class=\"params\">(<span class=\"number\">2023</span>,<span class=\"number\">7</span>,<span class=\"number\">21</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Date <span class=\"title\">d2</span><span class=\"params\">(<span class=\"number\">2022</span>,<span class=\"number\">8</span>,<span class=\"number\">21</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>,j = <span class=\"number\">2</span>;</span><br><span class=\"line\">i &lt; j;</span><br><span class=\"line\"><span class=\"comment\">// d1 &lt; d2 自定义类型如何比较？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">DateLess</span><span class=\"params\">(<span class=\"type\">const</span> Date&amp; d1,<span class=\"type\">const</span> Date&amp; d2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x1._year &lt; x2._year) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x1._year == x2._year &amp;&amp; x1._month &lt; x2._month) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x1._year == x2._year &amp;&amp; x1._month == x2._month &amp;&amp; x1._day &lt; x2._day) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">DateLess</span>(d1,d2);</span><br><span class=\"line\"><span class=\"comment\">// 但这样不太好，名字可能会比较抽象，并且不够优雅</span></span><br><span class=\"line\"><span class=\"comment\">// 所以c++有了运算符重载</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Date&amp; d1,<span class=\"type\">const</span> Date&amp; d2) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">d1 &lt; d2 等价于 <span class=\"keyword\">operator</span>&lt;(d1,d2)</span><br></pre></td></tr></table></figure>\n<h4 id=\"重载类型\"><a class=\"markdownIt-Anchor\" href=\"#重载类型\">#</a> 重载类型</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">operator</span>+();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>-();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>*();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>/();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>+=();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>-=();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>*=();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>/=();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>++();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>--();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>&lt;&lt;();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>&gt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>[]();</span><br><span class=\"line\"><span class=\"built_in\">operator</span>()();</span><br><span class=\"line\"><span class=\"keyword\">operator</span>&amp;();</span><br></pre></td></tr></table></figure>\n<h4 id=\"特殊重载\"><a class=\"markdownIt-Anchor\" href=\"#特殊重载\">#</a> 特殊 ++ 重载</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">++d1 -&gt; d1.<span class=\"keyword\">operator</span>++()</span><br><span class=\"line\"><span class=\"built_in\">operator</span>() &#123;&#125;</span><br><span class=\"line\">d1++ -&gt; d1.<span class=\"keyword\">operator</span>++(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">operator</span>(<span class=\"type\">int</span>) &#123;&#125;<span class=\"comment\">// 可以不接收</span></span><br></pre></td></tr></table></figure>\n<p>只读函数 <code>this</code>  指针可以换加  <code>const</code>  ，内部不涉及修改生成</p>\n<h3 id=\"友元\"><a class=\"markdownIt-Anchor\" href=\"#友元\">#</a> 友元</h3>\n<p>让一个函数或者类访问另一个类中的私有成员<br>\n关键字: <strong>friend</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">goodGay</span><span class=\"params\">(Building &amp;building)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>特点:</strong></p>\n<ol>\n<li>友元函数可以访问类的私有和保护成员，但不是类的成员函数</li>\n<li>友元函数不能用 <code>const</code>  修饰</li>\n<li>友元函数可以在类定义的任何地方声明</li>\n<li>一个函数可以是多个类的友元函数</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部类就是外部类的友元类</span></span><br><span class=\"line\"><span class=\"comment\">// B类受A类域和访问限定符的限制，其实是两个类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            A a;</span><br><span class=\"line\">            a._a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"type\">int</span> _b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化列表构造函数\"><a class=\"markdownIt-Anchor\" href=\"#初始化列表构造函数\">#</a> 初始化列表 (构造函数)</h3>\n<p>初始化列表：以一个<strong>冒号开始</strong>，接着时一个<strong>以逗号分隔的数据成员列表</strong>，每个成员变量后面跟一个<strong>放在括号中的初始值或者表达式。</strong></p>\n<p>初始化列表就是每个成员定义的地方</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day)</span><br><span class=\"line\">        : _year(year)</span><br><span class=\"line\">        , _month(month)</span><br><span class=\"line\">        , _day(day)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 或者</span></span><br><span class=\"line\">    <span class=\"built_in\">Date</span>(<span class=\"type\">int</span> year,<span class=\"type\">int</span> month,<span class=\"type\">int</span> day)</span><br><span class=\"line\">        : _year(year)</span><br><span class=\"line\">        , _month(month)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            _day = day;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化列表是解决这些问题的：</p>\n<ol>\n<li><code>const int _x</code>  ,  <code>int&amp; _y</code>  必须<strong>在定义时进行初始化</strong>，这时方法 2 的初始化就不行了</li>\n<li>没有默认构造的自定义类型，在<strong>定义的时候必须调带参构造</strong></li>\n</ol>\n<h3 id=\"static-静态成员\"><a class=\"markdownIt-Anchor\" href=\"#static-静态成员\">#</a> static - 静态成员</h3>\n<p>它不属于某个对象，属于整个类，存在静态区</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Date</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> n;<span class=\"comment\">// 不能给缺省值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> Date::n = <span class=\"number\">0</span>;<span class=\"comment\">// 类外定义</span></span><br></pre></td></tr></table></figure>\n<p><strong>静态函数</strong>：没有  <code>this</code>  指针，所以不能访问非静态成员</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/21/C++/c++%E5%85%A5%E9%97%A8/",
            "url": "http://example.com/2023/07/21/C++/c++%E5%85%A5%E9%97%A8/",
            "title": "c++入门",
            "date_published": "2023-07-21T14:52:20.951Z",
            "content_html": "<h2 id=\"cc的作用领域\"><a class=\"markdownIt-Anchor\" href=\"#cc的作用领域\">#</a> C/c++ 的作用领域</h2>\n<ol>\n<li>操作系统以及大型系统软件开发</li>\n<li>服务器端开发</li>\n<li>游戏开发</li>\n<li>嵌入式和物联网领域</li>\n<li>等等</li>\n</ol>\n<h2 id=\"第一个c程序\"><a class=\"markdownIt-Anchor\" href=\"#第一个c程序\">#</a> 第一个 c++ 程序</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>using namespace std</code>  是命名空间</p>\n<h2 id=\"命名空间\"><a class=\"markdownIt-Anchor\" href=\"#命名空间\">#</a> 命名空间</h2>\n<h3 id=\"为什么要有命名空间\"><a class=\"markdownIt-Anchor\" href=\"#为什么要有命名空间\">#</a> 为什么要有命名空间？</h3>\n<p>我们来看看 c 语言</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,rand);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样程序是可以正常执行的，但是我们加上一个头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,rand);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序就会报错，因为 rand 这个变量和头文件 <code>stdlib.h</code>  里面的变量命名冲突了</p>\n<p>所以在 c 语言中，是存在命名冲突的问题的</p>\n<p>c++ 命名空间就是解决<strong>命名冲突</strong>这个问题的</p>\n<h3 id=\"语法\"><a class=\"markdownIt-Anchor\" href=\"#语法\">#</a> 语法</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> acm &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> rand = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如何访问命名空间的变量</span></span><br><span class=\"line\">通过 acm::rand</span><br><span class=\"line\"><span class=\"comment\">// ::叫做域作用限定符</span></span><br></pre></td></tr></table></figure>\n<p>默认是在全局查找，不会进入命名空间查找</p>\n<p><code>using namespace acm</code>  会把命名空间全部展开</p>\n<p>展开之后就可以进入里面查找，但这个操作是危险的</p>\n<p>我们可以只展开一部分</p>\n<p><code>using acm::Add</code>  只展开了 Add 函数</p>\n<p>注：同名的命名空间会进行合并，不用担心命名空间名冲突</p>\n<h3 id=\"std\"><a class=\"markdownIt-Anchor\" href=\"#std\">#</a> std</h3>\n<p>std 是 c++ 标准库的命名空间</p>\n<p>头文件 <code>iostream</code>  里面的 <code>cout</code> , <code>endl</code>  等都封装在 std 这个命名空间里面</p>\n<h2 id=\"基础语法\"><a class=\"markdownIt-Anchor\" href=\"#基础语法\">#</a> 基础语法</h2>\n<h3 id=\"coutendl\"><a class=\"markdownIt-Anchor\" href=\"#coutendl\">#</a>  <code>cout</code> , <code>endl</code></h3>\n<p><code>cout</code>  控制台打印，会自动识别类型</p>\n<p><code>endl</code>  可以相当于 \\n</p>\n<h3 id=\"cin-输入\"><a class=\"markdownIt-Anchor\" href=\"#cin-输入\">#</a>  <code>cin</code>  输入</h3>\n<p>cin 可以自动识别类型</p>\n<h3 id=\"流插入运算符\"><a class=\"markdownIt-Anchor\" href=\"#流插入运算符\">#</a> &lt;&lt; 流插入运算符</h3>\n<h3 id=\"流提取\"><a class=\"markdownIt-Anchor\" href=\"#流提取\">#</a>  <code>&gt;&gt;</code>  流提取</h3>\n<h2 id=\"缺省参数\"><a class=\"markdownIt-Anchor\" href=\"#缺省参数\">#</a> 缺省参数</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Func</span><span class=\"params\">(<span class=\"type\">int</span> a = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>int a = 1</code>  就是缺省参数</p>\n<p>如果你不传参数，a 就会等于缺省值，这里是 1</p>\n<p>如果你传了参数，a 就会等于传的值</p>\n<p>缺省又分为全缺省和半缺省</p>\n<p><strong>全缺省</strong>就是全部都是缺省参数</p>\n<p><strong>半缺省</strong>有缺省参数也有普通参数，半缺省必须从右往左给缺省值</p>\n<p>注：声明和定义不能同时给缺省参数</p>\n<h2 id=\"函数重载\"><a class=\"markdownIt-Anchor\" href=\"#函数重载\">#</a> 函数重载</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<p>c++ 允许在<strong>同一作用域</strong>下声明多个<strong>相同名字的函数</strong>，但这些函数的<strong>形参列表不同</strong>（个数，类型或顺序不同）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1,2类型不同 // 1,3个数不同 //3,4顺序不同，跟名字无关，看的是类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> add)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">double</span> add)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> add;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">double</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left + (<span class=\"type\">int</span>)right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Add</span><span class=\"params\">(<span class=\"type\">double</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)left + right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回值不同不能构成重载</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么c支持函数重载而c语言不支持\"><a class=\"markdownIt-Anchor\" href=\"#为什么c支持函数重载而c语言不支持\">#</a> 为什么 c++ 支持函数重载而 c 语言不支持？</h3>\n<p>过程</p>\n<p>test.cpp</p>\n<p>预处理：头文件展开 / 宏替换 / 去掉注释 / 条件编译</p>\n<p>test.i</p>\n<p>编译：检查语法，生成汇编代码</p>\n<p>test.s</p>\n<p>汇编：将汇编代码生产二进制机器码</p>\n<p>test.o</p>\n<p>链接：合并链接，生成可执行程序</p>\n<p>c 语言是直接用函数名字充当符号表里面的名字</p>\n<p>c++ 则有一套函数名修饰规则，会把类型带进去</p>\n<p>所以函数重载类型不同，个数不同，位置不同，c++ 就可以区分</p>\n<h3 id=\"函数重载和缺省参数一起会导致一个问题\"><a class=\"markdownIt-Anchor\" href=\"#函数重载和缺省参数一起会导致一个问题\">#</a> 函数重载和缺省参数一起会导致一个问题</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 上面两个函数构成重载</span></span><br><span class=\"line\"><span class=\"built_in\">func</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>) <span class=\"comment\">// 这样没问题</span></span><br><span class=\"line\"><span class=\"built_in\">func</span>(<span class=\"number\">1</span>) <span class=\"comment\">// 这样就存在歧义了，不知道调哪个函数</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c关键字\"><a class=\"markdownIt-Anchor\" href=\"#c关键字\">#</a> c++ 关键字</h2>\n<p>c++ 总计 63 个关键字，c 语言 32 个关键字</p>\n<h2 id=\"引用\"><a class=\"markdownIt-Anchor\" href=\"#引用\">#</a> 引用</h2>\n<p>引用不会新定义一个变量，而是给已存在的变量取一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量公用一片内存空间。</p>\n<h3 id=\"语法-2\"><a class=\"markdownIt-Anchor\" href=\"#语法-2\">#</a> 语法</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; b = a;</span><br><span class=\"line\">cout &lt;&lt; &amp;a &lt;&lt; &amp;b &lt;&lt; endl;<span class=\"comment\">// 输出结果一样</span></span><br><span class=\"line\">b++; <span class=\"comment\">// a也会++</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"特性\"><a class=\"markdownIt-Anchor\" href=\"#特性\">#</a> 特性</h3>\n<ol>\n<li>引用在定义时必须初始化。</li>\n<li>一个变量可以有多个引用。</li>\n<li>引用一旦引用一个实体，不能再引用其他实体（不能再变）。</li>\n</ol>\n<h3 id=\"权限\"><a class=\"markdownIt-Anchor\" href=\"#权限\">#</a> 权限</h3>\n<ul>\n<li>权限可以缩小</li>\n<li>权限可以平移</li>\n<li>权限不能放大</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;b = a; <span class=\"comment\">// 权限的放大，不行</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;c = a;<span class=\"comment\">// 权限的平移</span></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> y = x;<span class=\"comment\">// 权限的缩小</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> &amp;v = x;<span class=\"comment\">// 类型转换时会产生临时对象，临时对象具有常性，不能用double &amp;v接收</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"引用和指针的区别\"><a class=\"markdownIt-Anchor\" href=\"#引用和指针的区别\">#</a> 引用和指针的区别</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *p = &amp;a;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref = a;<span class=\"comment\">// 语法上引用不开空间</span></span><br></pre></td></tr></table></figure>\n<p>但在底层引用是要开空间的，引用是按照指针方式实现的</p>\n<p>区别：</p>\n<ol>\n<li>引用概念上定义一个变量的别名，指针存储一个变量地址</li>\n<li>引用在定义时必须初始化，指针没有要求</li>\n<li>引用在初始化引用一个实体后，不能再引用其他实体，而指针可以指向任何一个同类型实体</li>\n<li>没有 NULL 引用，但有 NULL 指针</li>\n<li>在 <code>sizeof</code>  中含义不同，引用结果为引用类型大小，但指针始终是地址空间所占字节个数</li>\n<li>引用自加即引用的实体增加 1，指针自家即指针向后偏移一个类型大小</li>\n<li>有多级指针，但没有多级引用</li>\n<li>访问实体的方式不同</li>\n<li>引用比指针使用起来跟安全</li>\n</ol>\n<h2 id=\"内联函数\"><a class=\"markdownIt-Anchor\" href=\"#内联函数\">#</a> 内联函数</h2>\n<h3 id=\"宏的缺点\"><a class=\"markdownIt-Anchor\" href=\"#宏的缺点\">#</a> 宏的缺点</h3>\n<p>宏分为宏常量和宏函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> N 10</span></span><br><span class=\"line\"><span class=\"comment\">// 实现一个ADD的宏函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure>\n<p>可以看见要加很多括号，因为宏本质是一种替换。</p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>没有类型的严格限制</li>\n<li>针对频繁调用的小函数，不需要建立栈帧，提高了效率</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>容易出错，语法坑很多</li>\n<li>并且不能调试</li>\n<li>没有类型安全的检查</li>\n</ol>\n<h3 id=\"概念-2\"><a class=\"markdownIt-Anchor\" href=\"#概念-2\">#</a> 概念</h3>\n<p>以 <code>inline</code>  修饰的函数叫做内联函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内联函数会在调用时展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>比宏的优点：</p>\n<ol>\n<li>内联也不会建立栈帧</li>\n<li>可以进行调试</li>\n</ol>\n<p>注：内联函数不要声明和定义分离</p>\n<h2 id=\"autoc11\"><a class=\"markdownIt-Anchor\" href=\"#autoc11\">#</a> auto(c++11)</h2>\n<p><code>auto</code>  关键字可以自动推导类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> b = a;<span class=\"comment\">// 通过右边的值自动推导左边的值的类型</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> c = &amp;a;</span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp; d = a;</span><br></pre></td></tr></table></figure>\n<p>当类型很长的时候就可以简化代码。</p>\n<h3 id=\"什么时候使用内联函数\"><a class=\"markdownIt-Anchor\" href=\"#什么时候使用内联函数\">#</a> 什么时候使用内联函数？</h3>\n<p>一般内联机制用于规模较小，流程直接，频繁调用的函数。</p>\n<p>很多编译器也不支持内联递归函数。</p>\n<p>如果内联函数较为复杂，即使加了 <code>inline</code> ，编译器可能也不会把他当作内联函数</p>\n<h2 id=\"范围forc11\"><a class=\"markdownIt-Anchor\" href=\"#范围forc11\">#</a> 范围 for (c++11)</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> array[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 依次取数组中的数据赋值给e</span></span><br><span class=\"line\"><span class=\"comment\">// 自动迭代</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> e : array) &#123;</span><br><span class=\"line\">    cout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"指针空值nullptr\"><a class=\"markdownIt-Anchor\" href=\"#指针空值nullptr\">#</a> 指针空值 nullptr</h2>\n<p>在传统 c 中，NULL 其实是一个宏</p>\n<p><code>#define NULL 0</code></p>\n<p>所以在 c++ 中新定义了一个空指针 <code>nullptr</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">nullptr</span> <span class=\"comment\">// #define nullptr ((void*)0)</span></span><br><span class=\"line\">    <span class=\"comment\">//它所占字节数与(void*)0所占字节大小相同</span></span><br></pre></td></tr></table></figure>\n",
            "tags": []
        }
    ]
}