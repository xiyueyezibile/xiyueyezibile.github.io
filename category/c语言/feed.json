{
    "version": "https://jsonfeed.org/version/1",
    "title": "汐月也自闭了的个人博客 • All posts by \"c语言\" category",
    "description": "这个需求写不了",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%AD%98%E5%82%A8%E8%A7%84%E5%88%99/",
            "url": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%AD%98%E5%82%A8%E8%A7%84%E5%88%99/",
            "title": "浮点型存储规则",
            "date_published": "2023-05-26T10:07:29.770Z",
            "content_html": "<p>(-1)^S * M * 2^E</p>\n<p>(-1)^S 表示符号位，S 为 0 为正，S 为 1 为负</p>\n<p>M 表示有效数组，大于等于 1，小于 2</p>\n<p>2^E 表示指数为</p>\n<p>十进制转 2 进制</p>\n<p>(5.5)10 = (101.1)2 = (1.011 * 2^2)2 = (-1)^0 * 1.011 * 2^2</p>\n<p>S=0</p>\n<p>M=1.011</p>\n<p>E=2</p>\n<h2 id=\"对于32位的浮点数\"><a class=\"markdownIt-Anchor\" href=\"#对于32位的浮点数\">#</a> 对于 32 位的浮点数</h2>\n<p>最高一位是 S</p>\n<p>8bit 存 E</p>\n<p>23bit 存 M</p>\n<h2 id=\"对于64位浮点数\"><a class=\"markdownIt-Anchor\" href=\"#对于64位浮点数\">#</a> 对于 64 位浮点数</h2>\n<p>最高一位 S</p>\n<p>11bit 存 E</p>\n<p>52bit 存 M</p>\n<h2 id=\"-\"><a class=\"markdownIt-Anchor\" href=\"#-\">#</a> --------------------------------------</h2>\n<p>M 开头的数总是 1，可以舍去，不保存</p>\n<h2 id=\"指数e的存储\"><a class=\"markdownIt-Anchor\" href=\"#指数e的存储\">#</a> 指数 E 的存储</h2>\n<p>E 是一个无符号整数（unsigned int）</p>\n<p>但 E 可能是负数，所以规定 E 的真实值必须加上一个中间数</p>\n<p>对于 8 位，这个数是 127，对于 11 位，这个数是 1023</p>\n<h2 id=\"指数e的取出\"><a class=\"markdownIt-Anchor\" href=\"#指数e的取出\">#</a> 指数 E 的取出</h2>\n<h3 id=\"e不全为0或不全为1\"><a class=\"markdownIt-Anchor\" href=\"#e不全为0或不全为1\">#</a> E 不全为 0 或不全为 1</h3>\n<p>指数 E - 中间值 = 真实值</p>\n<p>M 加上第一位的 1</p>\n<h3 id=\"e全为0\"><a class=\"markdownIt-Anchor\" href=\"#e全为0\">#</a> E 全为 0</h3>\n<p>E = 1 - 中间值 = 真实值</p>\n<p>M 不再加 1，还原为 0.xxxxx, 这样做是为了表示 ±0 或接近 0 的很小的数字</p>\n<h3 id=\"e全为1\"><a class=\"markdownIt-Anchor\" href=\"#e全为1\">#</a> E 全为 1</h3>\n<p>这时，如果 M 全为 0，表示正负无穷大</p>\n<h2 id=\"例\"><a class=\"markdownIt-Anchor\" href=\"#例\">#</a> 例</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;stdio.h&gt;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tint n = 9;</span><br><span class=\"line\">\tfloat* pFloat = (float*)&amp;n;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,n);//9</span><br><span class=\"line\">\tprintf(&quot;%f\\n&quot;,*Float);//0</span><br><span class=\"line\">\t*pFloat = 9.0;</span><br><span class=\"line\">\tprintf(&quot;%d\\n&quot;,n);//一个很大的数字</span><br><span class=\"line\">\tprintf(&quot;%f\\n&quot;,*pFloat);//9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">\t浮点型和整型存储规则不一样，所以存储的二进制不一样</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/memcpy%E4%B8%8Ememmove/",
            "url": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/memcpy%E4%B8%8Ememmove/",
            "title": "memcpy与memmove",
            "date_published": "2023-05-26T10:07:29.764Z",
            "content_html": "<h2 id=\"memcpy\"><a class=\"markdownIt-Anchor\" href=\"#memcpy\">#</a> memcpy</h2>\n<p>memcpy 复制内存块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;string.h&gt;</span><br><span class=\"line\">void* memcpy(void* des,const void* src,size_t num);</span><br><span class=\"line\">//把num个字节从src复制到des,返回指向des首地址的void指针</span><br><span class=\"line\">注：des 与 src不应重叠并且至少有num个字节大小</span><br></pre></td></tr></table></figure>\n<h2 id=\"my_memcpy\"><a class=\"markdownIt-Anchor\" href=\"#my_memcpy\">#</a> my_memcpy</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void* my_memcpy(void* des,const void* src, size_t num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tassert(des &amp;&amp; src);</span><br><span class=\"line\">\tvoid* ret = des;</span><br><span class=\"line\">\twhile (num--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t//一个字节一个字节的复制</span><br><span class=\"line\">\t\t*(char*)des = *(char*)src;</span><br><span class=\"line\">\t\tdes = (char*)des + 1;</span><br><span class=\"line\">\t\tsrc = (char*)src + 1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"memmove\"><a class=\"markdownIt-Anchor\" href=\"#memmove\">#</a> memmove</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;sring.h&gt;</span><br><span class=\"line\">void *memmove(void* des,const void * src,size_t num);</span><br><span class=\"line\">//把num个字节从src复制到des,返回指向des首地址的void指针,src与des可以出现重叠</span><br></pre></td></tr></table></figure>\n<h2 id=\"my_memmove\"><a class=\"markdownIt-Anchor\" href=\"#my_memmove\">#</a> my_memmove</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//memmove较与memcpy的一个区别就是des和src允许重合</span><br><span class=\"line\">//如果有重合的部分，我们需要保证src改变之前就被复制到des里面</span><br><span class=\"line\">void* my_memmove(void* des,const void* src, size_t num)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tassert(des &amp;&amp; src);</span><br><span class=\"line\">\tvoid* ret = des;</span><br><span class=\"line\">\twhile (num--)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (src &gt; des)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t//当src的地址&gt;des的地址时，des的改变并不会影响src</span><br><span class=\"line\">\t\t\t*(char*)des = *(char*)src;</span><br><span class=\"line\">\t\t\tsrc = (char*)src + 1;</span><br><span class=\"line\">\t\t\tdes = (char*)des + 1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t//当src的地址&lt;=des的地址时,如果直接顺序复制可能会改变src</span><br><span class=\"line\">\t\t//如果是逆序则不会改变</span><br><span class=\"line\">\t\t\t*((char*)des + num) = *((char*)src + num);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/",
            "url": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/",
            "title": "C语言结构体类型所占空间的大小",
            "date_published": "2023-05-26T10:07:29.761Z",
            "content_html": "<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> a;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> b;</span><br><span class=\"line\">    <span class=\"type\">short</span> s;</span><br><span class=\"line\">    <span class=\"type\">short</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c语言结构体内存对齐规则\"><a class=\"markdownIt-Anchor\" href=\"#c语言结构体内存对齐规则\">#</a> C 语言结构体内存对齐规则：</h2>\n<p><strong>对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值</strong></p>\n<ol>\n<li>第一个成员在与结构体变量偏移量为 0 的地址处。</li>\n<li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</li>\n<li>结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。</li>\n<li>如果嵌套了结构体的情况，嵌套的结构体<strong>对齐到自己的最大对齐数的整数倍</strong>处，结构体的整体大小就是<strong>所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//第一个成员在与结构体变量偏移量为0的地址处。</span><br><span class=\"line\">0 char a</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">//其他成员变量要对齐到某个数字（对齐数8）的整数倍的地址处。</span><br><span class=\"line\">8 long long b</span><br><span class=\"line\">9 long long b</span><br><span class=\"line\">10 long long b</span><br><span class=\"line\">11 long long b</span><br><span class=\"line\">12 long long b</span><br><span class=\"line\">13 long long b</span><br><span class=\"line\">14 long long b</span><br><span class=\"line\">15 long long b</span><br><span class=\"line\">//其他成员变量要对齐到某个数字（对齐数4）的整数倍的地址处。</span><br><span class=\"line\">16 short s</span><br><span class=\"line\">17 short s</span><br><span class=\"line\">18 short s</span><br><span class=\"line\">19 short s</span><br><span class=\"line\">//其他成员变量要对齐到某个数字（对齐数4）的整数倍的地址处。</span><br><span class=\"line\">20 short c</span><br><span class=\"line\">21 short c</span><br><span class=\"line\">22 short c</span><br><span class=\"line\">23 short c</span><br><span class=\"line\">//结构体总大小为最大对齐数8（每个成员变量都有一个对齐数）的整数倍。</span><br></pre></td></tr></table></figure>\n<h2 id=\"位域\"><a class=\"markdownIt-Anchor\" href=\"#位域\">#</a> 位域</h2>\n<p>位域不同于一般的结构体成员，它以位为单位来定义成员的长度，因此在结构体中定义位域时，必须要指明位域成员所需要占用的二进制位数。</p>\n<p>位域变量仅限整型或者 char 类型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> a:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> b:<span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t如果相邻位域字段的类型相同，且其位宽之和小于类型的 sizeof 大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；<br>\n​\t如果相邻位域字段的类型相同，但其位宽之和大于类型的 sizeof 大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/",
            "url": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/",
            "title": "指针数组与数组指针",
            "date_published": "2023-05-26T10:07:29.757Z",
            "content_html": "<h2 id=\"含义\"><a class=\"markdownIt-Anchor\" href=\"#含义\">#</a> 含义</h2>\n<p><strong>指针数组</strong>：指针数组可以说成是” 指针的数组”，首先这个变量是一个数组，其次，” 指针” 修饰这个数组，意思是说这个数组的所有元素都是指针类型，在 32 位系统中，指针占四个字节。<br>\n<strong>数组指针</strong>：数组指针可以说成是” 数组的指针”，首先这个变量是一个指针，其次，” 数组” 修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。</p>\n<h2 id=\"指针数组\"><a class=\"markdownIt-Anchor\" href=\"#指针数组\">#</a> 指针数组</h2>\n<p>例：*<em>int <em>p[4]</em></em> ,[] 优先级高于解引用操作符，所以 p 先与 [] 结合成数组，数组里面的每个元素都是一个指针，总计有 4 个指针，在 32 位系统中指针大小是 4 个字节，所以该指针数组的大小为 16 个字节，从 p [0] 到 p [1] 会跳过 4 个字节。</p>\n<p><strong>数组指针不能代表二维数组</strong>，因为二维数组的每一行是固定长度的，而指针数组的每一行长度不固定，而且所占内存空间也可能不相同，并且二维数组的地址是连续的，而指针数组里面存放 4 个不相关的指针则不一定连续。</p>\n<h2 id=\"数组指针\"><a class=\"markdownIt-Anchor\" href=\"#数组指针\">#</a> 数组指针</h2>\n<p>例：<em><em>int (<em>p)[4]</em></em> , 数组指针本质是一个指针，指向了一个一维数组，指针指向的数据类型是 int [4]，方便理解我们可以看成 int [4] *p，指针做加减法运算的时候回前进（后退）指向的数据类型大小个字节，int [4] = 4 * 4 = 16，所以 p + 1 会前进（后退）16 个字节，这正好可以表示一个列数为 4 的整型二维数组的一行，故</em><em>数组指针可以用来保存二维数组的地址</em> *。</p>\n<h2 id=\"参考资料\"><a class=\"markdownIt-Anchor\" href=\"#参考资料\">#</a> 参考资料</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbl93ZW4vYXJ0aWNsZS9kZXRhaWxzLzUyNjk0MDY5\">csdn</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpcmVuZGFkYS9hcnRpY2xlL2RldGFpbHMvMTIyOTMxOTg3\">csdn</span></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/",
            "url": "http://example.com/2023/05/26/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/",
            "title": "数据类型转换",
            "date_published": "2023-05-26T10:07:29.751Z",
            "content_html": "<h2 id=\"自动类型转换\"><a class=\"markdownIt-Anchor\" href=\"#自动类型转换\">#</a> 自动类型转换</h2>\n<p>自动类型转换按照<strong>数据长度增加</strong>的方向进行，以保证数值不失真或精度不降低.</p>\n<h2 id=\"强制类型转换\"><a class=\"markdownIt-Anchor\" href=\"#强制类型转换\">#</a> 强制类型转换</h2>\n<p>程序员指明的一种类型转换</p>\n<h2 id=\"特性\"><a class=\"markdownIt-Anchor\" href=\"#特性\">#</a> 特性</h2>\n<p>类型转换只是临时的，都是为了本次运算进行的临时性转换</p>\n",
            "tags": []
        }
    ]
}